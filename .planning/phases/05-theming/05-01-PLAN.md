---
phase: 05-theming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/theme/colors.ts
  - src/utils/storage.ts
  - src/store/themeStore.ts
  - src/theme/ThemeContext.tsx
  - App.tsx
  - src/navigation/AppNavigator.tsx
autonomous: true

must_haves:
  truths:
    - "App resolves correct color palette based on preference + system scheme"
    - "Theme preference defaults to 'system' and persists to MMKV"
    - "ThemeProvider wraps the entire app and provides colors via context"
  artifacts:
    - path: "src/theme/colors.ts"
      provides: "Light and dark color palettes with shared ThemeColors type"
      exports: ["lightColors", "darkColors", "ThemeColors"]
    - path: "src/store/themeStore.ts"
      provides: "Zustand store for theme preference with MMKV persistence"
      exports: ["useThemeStore"]
    - path: "src/theme/ThemeContext.tsx"
      provides: "React context, ThemeProvider component, useTheme hook"
      exports: ["ThemeProvider", "useTheme"]
  key_links:
    - from: "src/theme/ThemeContext.tsx"
      to: "src/store/themeStore.ts"
      via: "useThemeStore selector for preference"
      pattern: "useThemeStore.*preference"
    - from: "src/theme/ThemeContext.tsx"
      to: "src/theme/colors.ts"
      via: "resolves lightColors or darkColors based on preference"
      pattern: "(lightColors|darkColors)"
    - from: "src/store/themeStore.ts"
      to: "src/utils/storage.ts"
      via: "saveThemePreference/loadThemePreference for MMKV persistence"
      pattern: "(saveThemePreference|loadThemePreference)"
    - from: "App.tsx"
      to: "src/theme/ThemeContext.tsx"
      via: "ThemeProvider wrapping NavigationContainer"
      pattern: "ThemeProvider"
---

<objective>
Create the theme infrastructure: dual color palettes, preference store with MMKV persistence, React context provider, and wire into the app shell.

Purpose: Foundation for dynamic theming — without this, components have no way to access theme-aware colors.
Output: ThemeProvider wrapping app, useTheme() hook available, preference persisted.
</objective>

<execution_context>
@/Users/giangnguyen/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/giangnguyen/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/theme/colors.ts
@src/utils/storage.ts
@App.tsx
@src/navigation/AppNavigator.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create color palettes, theme store, and ThemeContext</name>
  <files>
    src/theme/colors.ts
    src/utils/storage.ts
    src/store/themeStore.ts
    src/theme/ThemeContext.tsx
  </files>
  <action>
**1. Refactor `src/theme/colors.ts`** — Replace the single `colors` export with typed dual palettes:

- Export a `ThemeColors` type with all color keys: `background`, `surface`, `text`, `textSecondary`, `accent`, `cleared`, `selectedBorder`, `selectedBackground`.
- Export `darkColors: ThemeColors` with existing values: background=#121212, surface=#333333, text=#FFFFFF, textSecondary=#AAAAAA, accent=#BB86FC, cleared=transparent, selectedBorder=#BB86FC, selectedBackground=#444444.
- Export `lightColors: ThemeColors` with: background=#F5F5F5, surface=#FFFFFF, text=#1A1A1A, textSecondary=#666666, accent=#6200EE, cleared=transparent, selectedBorder=#6200EE, selectedBackground=#E8DEF8.
- Keep the old `export const colors = darkColors;` as a temporary backward-compat alias so the app still compiles while Plan 05-02 migrates components. This will be removed in Plan 05-02.

**2. Add theme persistence helpers to `src/utils/storage.ts`** — Follow existing patterns:

- Add `THEME_PREFERENCE: 'theme_preference'` to the `KEYS` object.
- Export `saveThemePreference(pref: string): void` — calls `getStorage()?.set(KEYS.THEME_PREFERENCE, pref)` with try/catch.
- Export `loadThemePreference(): string | null` — calls `getStorage()?.getString(KEYS.THEME_PREFERENCE) ?? null` with try/catch.

**3. Create `src/store/themeStore.ts`** — Zustand store following gameStore.ts patterns:

```typescript
type ThemePreference = 'system' | 'light' | 'dark';

interface ThemeState {
  preference: ThemePreference;
  setPreference: (pref: ThemePreference) => void;
}
```

- On store creation, call `loadThemePreference()` from storage. If result is 'light', 'dark', or 'system', use it; otherwise default to `'system'`.
- `setPreference` calls `saveThemePreference(pref)` then `set({ preference: pref })`.
- Export `useThemeStore` hook.

**4. Create `src/theme/ThemeContext.tsx`** — React context + provider:

- Create `ThemeContext` with `createContext<{ colors: ThemeColors; isDark: boolean }>`.
- `ThemeProvider` component: reads `useColorScheme()` from react-native AND `useThemeStore(s => s.preference)`. Resolves theme: if preference is 'system', use systemScheme (fallback to 'dark' if null); otherwise use preference directly. Memoize the context value with `useMemo`.
- Export `useTheme()` hook: `useContext(ThemeContext)` — returns `{ colors, isDark }`.
- Do NOT export preference/setPreference from this context — Settings screen will import `useThemeStore` directly for that.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Existing components still compile because the `colors` backward-compat export exists.
  </verify>
  <done>
`ThemeColors` type exported, `lightColors` and `darkColors` exported, `useThemeStore` persists to MMKV, `ThemeProvider` resolves colors from preference + system scheme, `useTheme()` hook returns `{ colors, isDark }`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ThemeProvider into App and update navigator + StatusBar</name>
  <files>
    App.tsx
    src/navigation/AppNavigator.tsx
  </files>
  <action>
**1. Update `App.tsx`:**

- Import `ThemeProvider` from `./src/theme/ThemeContext` and `useTheme` from same.
- Wrap `NavigationContainer` + `AppNavigator` inside `<ThemeProvider>`.
- Create an inner component (e.g., `AppContent`) that uses `useTheme()` to get `isDark`, then renders `<StatusBar style={isDark ? 'light' : 'dark'} />`. This is needed because `useTheme()` must be called inside `ThemeProvider`. Structure:

```tsx
function AppContent() {
  const { isDark } = useTheme();
  return (
    <NavigationContainer>
      <AppNavigator />
      <StatusBar style={isDark ? 'light' : 'dark'} />
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <AppContent />
    </ThemeProvider>
  );
}
```

**2. Update `src/navigation/AppNavigator.tsx`:**

- Remove the static `import { colors } from '../theme/colors'`.
- Import `useTheme` from `../theme/ThemeContext`.
- Move the navigator into a component body that calls `const { colors } = useTheme()`.
- Update the Settings screen `options` to use dynamic colors: `headerStyle: { backgroundColor: colors.background }`, `headerTintColor: colors.text`.
- Use a function form for `options` or set `screenOptions` on the navigator to make header colors reactive.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Run `npx expo start` — app launches, existing dark theme still displays correctly (backward-compat `colors` export used by unmigrated components). Settings screen header uses theme colors.
  </verify>
  <done>
ThemeProvider wraps entire app. StatusBar adapts to light/dark. Navigation headers use dynamic theme colors. App compiles and runs.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- App launches and displays existing dark theme (no visual regression)
- `useTheme()` hook is available and returns `{ colors, isDark }`
- `useThemeStore` preference defaults to 'system'
</verification>

<success_criteria>
- ThemeProvider wraps App, useTheme() returns resolved colors
- Theme preference store persists to MMKV with 'system' default
- Light and dark color palettes defined with shared type
- StatusBar style adapts to isDark
- Navigation header colors are dynamic
- No visual regression — existing components still work via backward-compat export
</success_criteria>

<output>
After completion, create `.planning/phases/05-theming/05-01-SUMMARY.md`
</output>
